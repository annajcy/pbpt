#!/usr/bin/env python3
"""Generate UVs for an OBJ mesh using xatlas and export a UV-mapped OBJ."""

from __future__ import annotations

import argparse
from pathlib import Path

import numpy as np
import xatlas


def _resolve_obj_index(raw_index: int, count: int, obj_path: Path) -> int:
    if raw_index == 0:
        raise RuntimeError(f"Invalid OBJ index 0 in {obj_path}")
    idx = raw_index - 1 if raw_index > 0 else count + raw_index
    if idx < 0 or idx >= count:
        raise RuntimeError(f"OBJ index out of range in {obj_path}: {raw_index}")
    return idx


def load_positions_and_triangles(obj_path: Path) -> tuple[np.ndarray, np.ndarray]:
    positions: list[list[float]] = []
    triangles: list[list[int]] = []

    for line_no, raw_line in enumerate(obj_path.read_text(encoding="utf-8").splitlines(), start=1):
        line = raw_line.split("#", 1)[0].strip()
        if not line:
            continue
        parts = line.split()
        tag = parts[0]

        if tag == "v":
            if len(parts) < 4:
                raise RuntimeError(f"Malformed vertex at {obj_path}:{line_no}")
            positions.append([float(parts[1]), float(parts[2]), float(parts[3])])
        elif tag == "f":
            if len(parts) < 4:
                continue
            face_indices: list[int] = []
            for token in parts[1:]:
                v_str = token.split("/", 1)[0]
                if not v_str:
                    raise RuntimeError(f"Malformed face token at {obj_path}:{line_no}")
                face_indices.append(_resolve_obj_index(int(v_str), len(positions), obj_path))

            for i in range(1, len(face_indices) - 1):
                triangles.append([face_indices[0], face_indices[i], face_indices[i + 1]])

    if not positions:
        raise RuntimeError(f"No vertices found in {obj_path}")
    if not triangles:
        raise RuntimeError(f"No faces found in {obj_path}")

    return np.asarray(positions, dtype=np.float32), np.asarray(triangles, dtype=np.uint32)


def write_uv_obj(
    output_path: Path,
    mapped_positions: np.ndarray,
    mapped_uvs: np.ndarray,
    mapped_triangles: np.ndarray,
) -> None:
    lines: list[str] = [
        "# Auto-generated by script/generate_bunny_uv.py",
        "",
    ]

    for v in mapped_positions:
        lines.append(f"v {v[0]:.8f} {v[1]:.8f} {v[2]:.8f}")
    for uv in mapped_uvs:
        lines.append(f"vt {uv[0]:.8f} {uv[1]:.8f}")

    for tri in mapped_triangles:
        a = int(tri[0]) + 1
        b = int(tri[1]) + 1
        c = int(tri[2]) + 1
        lines.append(f"f {a}/{a} {b}/{b} {c}/{c}")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def main() -> int:
    root = Path(__file__).resolve().parents[1]
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--input",
        type=Path,
        default=root / "asset/model/stanford_bunny.obj",
        help="Input OBJ mesh path.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=root / "asset/scene/cbox/meshes/bunny_uv.obj",
        help="Output OBJ mesh path with generated UVs.",
    )
    args = parser.parse_args()

    input_path = args.input if args.input.is_absolute() else (root / args.input)
    output_path = args.output if args.output.is_absolute() else (root / args.output)

    if not input_path.exists():
        raise SystemExit(f"Input OBJ not found: {input_path}")

    positions, triangles = load_positions_and_triangles(input_path)
    vmapping, indices, uvs = xatlas.parametrize(positions, triangles)

    mapped_positions = positions[vmapping]
    write_uv_obj(output_path, mapped_positions, uvs, indices)
    print(f"Wrote UV mesh: {output_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
