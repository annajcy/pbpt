/**
 * @file
 * @brief Monte Carlo domains and integral helpers for radiometric quantities.
 */
#pragma once

#include <cstdlib>
#include <utility>

#include "math/function.hpp"
#include "math/normal.hpp"
#include "math/point.hpp"
#include "math/vector.hpp"
#include "math/sampling.hpp"

namespace pbpt::integrator {

/**
 * @brief CRTP base class for domains that can be sampled for integration.
 *
 * A domain defines:
 * - @c sample_one_impl() to draw a sample and return (sample).
 * - @c pdf_impl(sample) to return a PDF of the sample.
 *
 * @tparam Derived Concrete domain type.
 * @tparam T       Scalar type.
 */
template<typename T, typename Derived, typename SampleType>
class IntegrableDomain {
public:
    /// Type of samples generated by this domain.
    using sample_type = SampleType;

    /// Draw a single sample and return it together with its PDF.
    template<typename RNG>
    auto sample_one(RNG& rng2d) const {
        return as_derived().sample_one_impl(rng2d);
    }

    /// Return the (usually constant) PDF of this domain.
    constexpr auto pdf(const SampleType& sample) const {
        return as_derived().pdf_impl(sample);
    }

    /**
     * @brief Apply a function to a number of independent samples.
     *
     * Calls @p func(sample, pdf) for each of @p count samples.
     */
    template<typename RNG, typename Func>
    void foreach_sample(int count, RNG& rng, Func&& func) const {
        for (int i = 0; i < count; ++i) {
            auto sample = sample_one(rng);
            auto pdf = this->pdf(sample);
            func(sample, pdf);
        }
    }

    /// Access the derived domain (mutable).
    Derived& as_derived() {
        return static_cast<Derived&>(*this);
    }

    /// Access the derived domain (const).
    const Derived& as_derived() const {
        return static_cast<const Derived&>(*this);
    }

};

/**
 * @brief Uniformly sampling of the unit hemisphere with respect to solid angle.
 * 
 */

template<typename T>
class UniformHemisphereDomain : public IntegrableDomain<T, UniformHemisphereDomain<T>, math::Vector<T,3>> {
    friend class IntegrableDomain<T, UniformHemisphereDomain<T>, math::Vector<T,3>>;
private:
    template<typename RNG>
    math::Vector<T, 3> sample_one_impl(RNG& rng2d) const {
        auto uv = math::Point<T, 2>::from_array(rng2d.generate_uniform(T(0), T(1))); // uv ∈ [0,1]^2
        auto dir = math::sample_uniform_hemisphere(uv).to_vector();
        return dir;
    }

    constexpr T pdf_impl(const math::Vector<T, 3>& sample) const {
        return math::sample_uniform_hemisphere_pdf<T>();
    }
};

/**
 * @brief CosineWeighted sampling of the unit hemisphere with respect to solid angle.
 */
template<typename T>
class CosineWeightedHemisphereDomain : public IntegrableDomain<T, CosineWeightedHemisphereDomain<T>, math::Vector<T,3>> {
    friend class IntegrableDomain<T, CosineWeightedHemisphereDomain<T>, math::Vector<T,3>>;
private:
    template<typename RNG>
    math::Vector<T, 3> sample_one_impl(RNG& rng2d) const {
        auto uv = math::Point<T, 2>::from_array(rng2d.generate_uniform(T(0), T(1))); // uv ∈ [0,1]^2
        auto dir = math::sample_cosine_weighted_hemisphere(uv).to_vector();
        return dir;
    }

    constexpr T pdf_impl(
        const math::Vector<T, 3>& sample
    ) const {
        auto p = math::Point<T, 3>(sample);
        return math::sample_cosine_weighted_hemisphere_pdf(p);
    }
};


/**
 * @brief Uniform sampling over a unit disk in the xy-plane.
 */
template<typename T>
class UniformDiskDomain : public IntegrableDomain<T, UniformDiskDomain<T>, math::Point<T, 2>> {
    friend class IntegrableDomain<T, UniformDiskDomain<T>, math::Point<T, 2>>;
private:
    template<typename RNG>
    math::Point<T, 2> sample_one_impl(RNG& rng2d) const {
        auto u01 = math::Point<T, 2>::from_array(rng2d.generate_uniform(0, 1));
        auto point = math::sample_uniform_disk_concentric(u01);
        return point;
    }

    constexpr T pdf_impl(
        const math::Point<T, 2>& /*sample*/
    ) const {
        return T(1) / (math::pi_v<T>);
    }
};


template<typename T>
/**
 * @brief Geometric and shading information for a sampled surface point.
 *
 * Stores the sampled position and its associated surface normal and
 * is typically used as the payload of area-sampling domains.
 */
struct SurfaceInfo {
    /// Sampled position on the surface.
    math::Point<T, 3> position;
    /// Surface normal at the sampled position.
    math::Normal<T, 3> normal;
};

/**
 * @brief Uniform sampling over a parallelogram surface.
 *
 * The parallelogram is defined by an origin and two edge vectors.
 */
template<typename T>
class UniformParallelogramAreaDomain : public IntegrableDomain<T, UniformParallelogramAreaDomain<T>, SurfaceInfo<T>> {
    friend class IntegrableDomain<T, UniformParallelogramAreaDomain<T>, SurfaceInfo<T>>;

private:
    math::Point<T, 3> m_origin;
    math::Vector<T, 3> m_edge1;
    math::Vector<T, 3> m_edge2;

    math::Normal<T, 3> m_normal;
    T m_area;

public:
    /// Type of samples generated by this domain (surface position and normal).
    using sample_type = SurfaceInfo<T>;

    /**
     * @brief Constructs a parallelogram sampling domain.
     *
     * @param origin Origin corner of the parallelogram.
     * @param edge1  First edge vector.
     * @param edge2  Second edge vector.
     *
     * The surface normal and area are derived from the cross product of
     * the edge vectors.
     */
    UniformParallelogramAreaDomain(
        const math::Point<T, 3>& origin, 
        const math::Vector<T, 3>& edge1, 
        const math::Vector<T, 3>& edge2
    ) : m_origin(origin), m_edge1(edge1), m_edge2(edge2) {
            m_normal = math::Normal<T, 3>(cross(m_edge1, m_edge2).normalized());
            m_area = cross(m_edge1, m_edge2).length();
            math::assert_if(math::is_less_equal(m_area, T(0)), "Parallelogram area must be > 0");
        }

    /// Returns the total area of the parallelogram.
    constexpr T area() const {
        return m_area;
    }

    /// Returns the unit surface normal of the parallelogram.
    constexpr math::Normal<T, 3> normal() const {
        return m_normal;
    }
    
private:
    template<typename RNG>
    SurfaceInfo<T> sample_one_impl(RNG& rng2d) const {
        auto uv = rng2d.generate_uniform(0.0, 1.0);
        auto p = m_origin + uv[0] * m_edge1 + uv[1] * m_edge2;
        SurfaceInfo<T> info{p, normal()};
        return info;
    }

    constexpr T pdf_impl(
        const SurfaceInfo<T>& /*sample*/
    ) const {
        return T(1) / area();
    }
};

/**
 * @brief Monte Carlo integration over a sampling domain.
 *
 * Draws @p sample_count independent samples from @p domain, evaluates
 * @p func(sample) for each, and accumulates the standard importance
 * sampling estimator func(sample) / pdf. The final result is the
 * arithmetic mean of these estimates.
 *
 * @tparam T      Scalar type used inside the domain.
 * @tparam Domain IntegrableDomain type that provides samples and PDFs.
 * @tparam Func   Callable taking a sample_type and returning a value.
 * @tparam RNG    Random number generator type.
 *
 * @param domain       Sampling domain to integrate over.
 * @param func         Integrand evaluated at samples.
 * @param sample_count Number of Monte Carlo samples.
 * @param rng          Random number generator used for sampling.
 */
template<typename T, typename Domain, typename Func, typename RNG>
auto integrate(const Domain& domain, const Func& func, int sample_count, RNG& rng) {
    using R = decltype(
        std::declval<const Func&>()(
            std::declval<typename Domain::sample_type>()
        ) / static_cast<T>(std::declval<int>())
    );
    
    R result = R{};
    domain.foreach_sample(sample_count, rng, [&](const auto& sample, const auto& pdf) {
        result += func(sample) / pdf;
    });
    return result / T(sample_count);
}

} 
